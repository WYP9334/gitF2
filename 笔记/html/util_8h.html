<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libevent-2.1.8: E:/笔记/libevent-2.1.8-stable/include/event2/util.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libevent-2.1.8
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_885cc87fac2d91e269af0a5a959fa5f6.html">E:</a></li><li class="navelem"><a class="el" href="dir_e0737d9736c30754717c067382877683.html">笔记</a></li><li class="navelem"><a class="el" href="dir_377e8ef8e80a313d1c3a754eb3f26a1b.html">libevent-2.1.8-stable</a></li><li class="navelem"><a class="el" href="dir_5708c2d9d68deda293c436e4a44eaa6a.html">include</a></li><li class="navelem"><a class="el" href="dir_12d53d16af40e50e6892e028525770af.html">event2</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">util.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;event2/visibility.h&gt;</code><br />
<code>#include &lt;event2/event-config.h&gt;</code><br />
<code>#include &lt;stdarg.h&gt;</code><br />
<code>#include &lt;sys/socket.h&gt;</code><br />
<code>#include &lt;time.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for util.h:</div>
<div class="dyncontent">
<div class="center"><img src="util_8h__incl.png" border="0" usemap="#_e_1_2_xE7_xAC_x94_xE8_xAE_xB0_2libevent-2_81_88-stable_2include_2event2_2util_8h" alt=""/></div>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="util_8h__dep__incl.png" border="0" usemap="#_e_1_2_xE7_xAC_x94_xE8_xAE_xB0_2libevent-2_81_88-stable_2include_2event2_2util_8hdep" alt=""/></div>
</div>
</div>
<p><a href="util_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevutil__addrinfo.html">evutil_addrinfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a1aa9b4bfabbeaae5ba828e808938fa2c"><td class="memItemLeft" align="right" valign="top"><a id="a1aa9b4bfabbeaae5ba828e808938fa2c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ev_socklen_t</b>&#160;&#160;&#160;socklen_t</td></tr>
<tr class="separator:a1aa9b4bfabbeaae5ba828e808938fa2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef0023565082a65020f6e56be59fd0b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a>&#160;&#160;&#160;int</td></tr>
<tr class="separator:a7ef0023565082a65020f6e56be59fd0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb16e8c516213aebb503b6d764139d55"><td class="memItemLeft" align="right" valign="top"><a id="afb16e8c516213aebb503b6d764139d55"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EV_MONOT_PRECISE</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:afb16e8c516213aebb503b6d764139d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69bb004732dec77429200727420ad50c"><td class="memItemLeft" align="right" valign="top"><a id="a69bb004732dec77429200727420ad50c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EV_MONOT_FALLBACK</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:a69bb004732dec77429200727420ad50c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa70c6baf0f9ac418407245579ec2a168"><td class="memItemLeft" align="right" valign="top"><a id="aa70c6baf0f9ac418407245579ec2a168"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_CLOSESOCKET</b>(s)&#160;&#160;&#160;<a class="el" href="util_8h.html#a5cfa6c13c62d17570a7d5f6d3541ff5b">evutil_closesocket</a>(s)</td></tr>
<tr class="separator:aa70c6baf0f9ac418407245579ec2a168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a94a2e72982e708333486cf72aab941"><td class="memItemLeft" align="right" valign="top"><a id="a9a94a2e72982e708333486cf72aab941"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_SOCKET_ERROR</b>()&#160;&#160;&#160;(errno)</td></tr>
<tr class="separator:a9a94a2e72982e708333486cf72aab941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b4fae7790599f7b58e8c269f6b29d8"><td class="memItemLeft" align="right" valign="top"><a id="ae8b4fae7790599f7b58e8c269f6b29d8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_SET_SOCKET_ERROR</b>(errcode)&#160;&#160;&#160;do { errno = (errcode); } while (0)</td></tr>
<tr class="separator:ae8b4fae7790599f7b58e8c269f6b29d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f952fb0f16b057d931fd38ee9bdf5e"><td class="memItemLeft" align="right" valign="top"><a id="a28f952fb0f16b057d931fd38ee9bdf5e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>evutil_socket_geterror</b>(sock)&#160;&#160;&#160;(errno)</td></tr>
<tr class="separator:a28f952fb0f16b057d931fd38ee9bdf5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ea5ef81ddcfb299e4867d362ad8654"><td class="memItemLeft" align="right" valign="top"><a id="ad5ea5ef81ddcfb299e4867d362ad8654"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>evutil_socket_error_to_string</b>(errcode)&#160;&#160;&#160;(strerror(errcode))</td></tr>
<tr class="separator:ad5ea5ef81ddcfb299e4867d362ad8654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a42f43db6aaf6e99736329b6611175d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a1a42f43db6aaf6e99736329b6611175d">evutil_timercmp</a>(tvp,  uvp,  cmp)</td></tr>
<tr class="separator:a1a42f43db6aaf6e99736329b6611175d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a393a0aee6129d132a3dd488366352bf2"><td class="memItemLeft" align="right" valign="top"><a id="a393a0aee6129d132a3dd488366352bf2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>evutil_timerisset</b>(tvp)&#160;&#160;&#160;((tvp)-&gt;tv_sec || (tvp)-&gt;tv_usec)</td></tr>
<tr class="separator:a393a0aee6129d132a3dd488366352bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c296955d33624c18bd4811730caa417"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a4c296955d33624c18bd4811730caa417">evutil_offsetof</a>(type,  field)&#160;&#160;&#160;((off_t)(&amp;((type *)0)-&gt;field))</td></tr>
<tr class="separator:a4c296955d33624c18bd4811730caa417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Standard integer types.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Integer type definitions for types that are supposed to be defined in the C99-specified stdint.h. Shamefully, some platforms do not include stdint.h, so we need to replace it. (If you are on a platform like this, your C headers are now over 10 years out of date. You should bug them to do something about this.)</p>
<p>We define:</p>
<dl>
<dt>ev_uint64_t, ev_uint32_t, ev_uint16_t, ev_uint8_t </dt>
<dd>unsigned integer types of exactly 64, 32, 16, and 8 bits respectively. </dd>
<dt>ev_int64_t, ev_int32_t, ev_int16_t, ev_int8_t </dt>
<dd>signed integer types of exactly 64, 32, 16, and 8 bits respectively. </dd>
<dt>ev_uintptr_t, ev_intptr_t </dt>
<dd>unsigned/signed integers large enough to hold a pointer without loss of bits. </dd>
<dt>ev_ssize_t </dt>
<dd>A signed type of the same size as size_t </dd>
<dt>ev_off_t </dt>
<dd>A signed type typically used to represent offsets within a (potentially large) file </dd>
</dl>
</div></td></tr>
<tr class="memitem:ad9052cd1d14b92812de0796d84af5604"><td class="memItemLeft" align="right" valign="top"><a id="ad9052cd1d14b92812de0796d84af5604"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ev_uint8_t</b>&#160;&#160;&#160;unsigned char</td></tr>
<tr class="separator:ad9052cd1d14b92812de0796d84af5604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab642ae86b43a6d75c52811eb686f0837"><td class="memItemLeft" align="right" valign="top"><a id="ab642ae86b43a6d75c52811eb686f0837"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ev_int8_t</b>&#160;&#160;&#160;signed char</td></tr>
<tr class="separator:ab642ae86b43a6d75c52811eb686f0837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bf36939a205bd52df25c40fe44b7fd7"><td class="memItemLeft" align="right" valign="top"><a id="a6bf36939a205bd52df25c40fe44b7fd7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ev_uintptr_t</b>&#160;&#160;&#160;ev_uint32_t</td></tr>
<tr class="separator:a6bf36939a205bd52df25c40fe44b7fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4913c495b489d419353b3d1512505ea2"><td class="memItemLeft" align="right" valign="top"><a id="a4913c495b489d419353b3d1512505ea2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ev_intptr_t</b>&#160;&#160;&#160;ev_int32_t</td></tr>
<tr class="separator:a4913c495b489d419353b3d1512505ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fce2c187cee381db4bf5276f76a39e8"><td class="memItemLeft" align="right" valign="top"><a id="a9fce2c187cee381db4bf5276f76a39e8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ev_ssize_t</b>&#160;&#160;&#160;ssize_t</td></tr>
<tr class="separator:a9fce2c187cee381db4bf5276f76a39e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f968b0d453ef37a233e2d40860296a6"><td class="memItemLeft" align="right" valign="top"><a id="a2f968b0d453ef37a233e2d40860296a6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ev_off_t</b>&#160;&#160;&#160;off_t</td></tr>
<tr class="separator:a2f968b0d453ef37a233e2d40860296a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Limits for integer types</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These macros hold the largest or smallest values possible for the ev_[u]int*_t types. </p>
</div></td></tr>
<tr class="memitem:a34cff4b5f64165a133fd51d3004964db"><td class="memItemLeft" align="right" valign="top"><a id="a34cff4b5f64165a133fd51d3004964db"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EV_UINT64_MAX</b>&#160;&#160;&#160;((((ev_uint64_t)0xffffffffUL) &lt;&lt; 32) | 0xffffffffUL)</td></tr>
<tr class="separator:a34cff4b5f64165a133fd51d3004964db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a5b615c4a5ffb69122263c69d8bb091"><td class="memItemLeft" align="right" valign="top"><a id="a7a5b615c4a5ffb69122263c69d8bb091"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EV_INT64_MAX</b>&#160;&#160;&#160;((((ev_int64_t) 0x7fffffffL) &lt;&lt; 32) | 0xffffffffL)</td></tr>
<tr class="separator:a7a5b615c4a5ffb69122263c69d8bb091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20073b67f3e9cdda20215246b11c4f6d"><td class="memItemLeft" align="right" valign="top"><a id="a20073b67f3e9cdda20215246b11c4f6d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EV_INT64_MIN</b>&#160;&#160;&#160;((-EV_INT64_MAX) - 1)</td></tr>
<tr class="separator:a20073b67f3e9cdda20215246b11c4f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a815ab1b931ad8d2b11da526b9071282a"><td class="memItemLeft" align="right" valign="top"><a id="a815ab1b931ad8d2b11da526b9071282a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EV_UINT32_MAX</b>&#160;&#160;&#160;((ev_uint32_t)0xffffffffUL)</td></tr>
<tr class="separator:a815ab1b931ad8d2b11da526b9071282a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbfb8c4ad3c2b8d2bec82787c9f0eaa3"><td class="memItemLeft" align="right" valign="top"><a id="adbfb8c4ad3c2b8d2bec82787c9f0eaa3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EV_INT32_MAX</b>&#160;&#160;&#160;((ev_int32_t) 0x7fffffffL)</td></tr>
<tr class="separator:adbfb8c4ad3c2b8d2bec82787c9f0eaa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7899efdfa42ebe54093c85fbc35ba8e5"><td class="memItemLeft" align="right" valign="top"><a id="a7899efdfa42ebe54093c85fbc35ba8e5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EV_INT32_MIN</b>&#160;&#160;&#160;((-EV_INT32_MAX) - 1)</td></tr>
<tr class="separator:a7899efdfa42ebe54093c85fbc35ba8e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af85ec3c0198df9bbb370d9c70f1fd2f4"><td class="memItemLeft" align="right" valign="top"><a id="af85ec3c0198df9bbb370d9c70f1fd2f4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EV_UINT16_MAX</b>&#160;&#160;&#160;((ev_uint16_t)0xffffUL)</td></tr>
<tr class="separator:af85ec3c0198df9bbb370d9c70f1fd2f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6271a010b87f8e78edfb3d576d16909"><td class="memItemLeft" align="right" valign="top"><a id="af6271a010b87f8e78edfb3d576d16909"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EV_INT16_MAX</b>&#160;&#160;&#160;((ev_int16_t) 0x7fffL)</td></tr>
<tr class="separator:af6271a010b87f8e78edfb3d576d16909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10afd44462363963e6cdfc20e10d250a"><td class="memItemLeft" align="right" valign="top"><a id="a10afd44462363963e6cdfc20e10d250a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EV_INT16_MIN</b>&#160;&#160;&#160;((-EV_INT16_MAX) - 1)</td></tr>
<tr class="separator:a10afd44462363963e6cdfc20e10d250a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8af5a509193ad75cdd20e77a8422d84d"><td class="memItemLeft" align="right" valign="top"><a id="a8af5a509193ad75cdd20e77a8422d84d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EV_UINT8_MAX</b>&#160;&#160;&#160;255</td></tr>
<tr class="separator:a8af5a509193ad75cdd20e77a8422d84d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae959d5851ca0690f9da6e47fbb8056c9"><td class="memItemLeft" align="right" valign="top"><a id="ae959d5851ca0690f9da6e47fbb8056c9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EV_INT8_MAX</b>&#160;&#160;&#160;127</td></tr>
<tr class="separator:ae959d5851ca0690f9da6e47fbb8056c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4adcc386a7cb06436af4618301c8b03"><td class="memItemLeft" align="right" valign="top"><a id="aa4adcc386a7cb06436af4618301c8b03"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EV_INT8_MIN</b>&#160;&#160;&#160;((-EV_INT8_MAX) - 1)</td></tr>
<tr class="separator:aa4adcc386a7cb06436af4618301c8b03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Limits for SIZE_T and SSIZE_T</div></td></tr>
<tr class="memitem:a59e6c7724ce1f7e0562d6e24021acb10"><td class="memItemLeft" align="right" valign="top"><a id="a59e6c7724ce1f7e0562d6e24021acb10"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EV_SSIZE_MIN</b>&#160;&#160;&#160;((-EV_SSIZE_MAX) - 1)</td></tr>
<tr class="separator:a59e6c7724ce1f7e0562d6e24021acb10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Manipulation macros for struct timeval.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>We define replacements for timeradd, timersub, timerclear, timercmp, and timerisset. </p>
</div></td></tr>
<tr class="memitem:a6182f91a8aede88fac748b3f424cbb6d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>evutil_timeradd</b>(tvp,  uvp,  vvp)</td></tr>
<tr class="separator:a6182f91a8aede88fac748b3f424cbb6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab75cdb8eae7b33eac738c46356967399"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>evutil_timersub</b>(tvp,  uvp,  vvp)</td></tr>
<tr class="separator:ab75cdb8eae7b33eac738c46356967399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add4999b82eab8bcb8becc8cb079341a0"><td class="memItemLeft" align="right" valign="top"><a id="add4999b82eab8bcb8becc8cb079341a0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>evutil_timerclear</b>(tvp)&#160;&#160;&#160;(tvp)-&gt;tv_sec = (tvp)-&gt;tv_usec = 0</td></tr>
<tr class="separator:add4999b82eab8bcb8becc8cb079341a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">evutil_getaddrinfo() error codes</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These values are possible error codes for <a class="el" href="util_8h.html#a0f36c2fc48c644a4f56347a25c585cc9">evutil_getaddrinfo()</a> and related functions. </p>
</div></td></tr>
<tr class="memitem:aaf1a2e7213ceab1be80a752ec8cbd109"><td class="memItemLeft" align="right" valign="top"><a id="aaf1a2e7213ceab1be80a752ec8cbd109"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_EAI_ADDRFAMILY</b>&#160;&#160;&#160;-901</td></tr>
<tr class="separator:aaf1a2e7213ceab1be80a752ec8cbd109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1cb726c0bf1ff8907dfc3b4171742ac"><td class="memItemLeft" align="right" valign="top"><a id="ae1cb726c0bf1ff8907dfc3b4171742ac"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_EAI_AGAIN</b>&#160;&#160;&#160;-902</td></tr>
<tr class="separator:ae1cb726c0bf1ff8907dfc3b4171742ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f1ed6215f25714f371551cb7467ad7"><td class="memItemLeft" align="right" valign="top"><a id="ac5f1ed6215f25714f371551cb7467ad7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_EAI_BADFLAGS</b>&#160;&#160;&#160;-903</td></tr>
<tr class="separator:ac5f1ed6215f25714f371551cb7467ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76916ba557e677dafe9c1fd7da89f2b3"><td class="memItemLeft" align="right" valign="top"><a id="a76916ba557e677dafe9c1fd7da89f2b3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_EAI_FAIL</b>&#160;&#160;&#160;-904</td></tr>
<tr class="separator:a76916ba557e677dafe9c1fd7da89f2b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df5ae5495d39cb471ef5403c2823ab4"><td class="memItemLeft" align="right" valign="top"><a id="a0df5ae5495d39cb471ef5403c2823ab4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_EAI_FAMILY</b>&#160;&#160;&#160;-905</td></tr>
<tr class="separator:a0df5ae5495d39cb471ef5403c2823ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03351808979dfac04060773ebfd3c06b"><td class="memItemLeft" align="right" valign="top"><a id="a03351808979dfac04060773ebfd3c06b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_EAI_MEMORY</b>&#160;&#160;&#160;-906</td></tr>
<tr class="separator:a03351808979dfac04060773ebfd3c06b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d7b69a78006c0f48d88f88e9b55334b"><td class="memItemLeft" align="right" valign="top"><a id="a1d7b69a78006c0f48d88f88e9b55334b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_EAI_NODATA</b>&#160;&#160;&#160;-907</td></tr>
<tr class="separator:a1d7b69a78006c0f48d88f88e9b55334b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab100c4d4e222d5cdfa2aebcf3a0140e9"><td class="memItemLeft" align="right" valign="top"><a id="ab100c4d4e222d5cdfa2aebcf3a0140e9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_EAI_NONAME</b>&#160;&#160;&#160;-908</td></tr>
<tr class="separator:ab100c4d4e222d5cdfa2aebcf3a0140e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2cc1d8d4eead1bc0e15eaae2edaf668"><td class="memItemLeft" align="right" valign="top"><a id="ab2cc1d8d4eead1bc0e15eaae2edaf668"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_EAI_SERVICE</b>&#160;&#160;&#160;-909</td></tr>
<tr class="separator:ab2cc1d8d4eead1bc0e15eaae2edaf668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30b335f48757b2ba10da69f80a87a46"><td class="memItemLeft" align="right" valign="top"><a id="ac30b335f48757b2ba10da69f80a87a46"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_EAI_SOCKTYPE</b>&#160;&#160;&#160;-910</td></tr>
<tr class="separator:ac30b335f48757b2ba10da69f80a87a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03273ded49de60ab08e489b7d5d5e17e"><td class="memItemLeft" align="right" valign="top"><a id="a03273ded49de60ab08e489b7d5d5e17e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_EAI_SYSTEM</b>&#160;&#160;&#160;-911</td></tr>
<tr class="separator:a03273ded49de60ab08e489b7d5d5e17e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34127164b338d82707034566b100b4cb"><td class="memItemLeft" align="right" valign="top"><a id="a34127164b338d82707034566b100b4cb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_EAI_CANCEL</b>&#160;&#160;&#160;-90001</td></tr>
<tr class="separator:a34127164b338d82707034566b100b4cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2611f48d74207f6e996189e71ca9742f"><td class="memItemLeft" align="right" valign="top"><a id="a2611f48d74207f6e996189e71ca9742f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_AI_PASSIVE</b>&#160;&#160;&#160;0x1000</td></tr>
<tr class="separator:a2611f48d74207f6e996189e71ca9742f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1fbbc2f3b038e60fd97a620bff9230"><td class="memItemLeft" align="right" valign="top"><a id="a1b1fbbc2f3b038e60fd97a620bff9230"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_AI_CANONNAME</b>&#160;&#160;&#160;0x2000</td></tr>
<tr class="separator:a1b1fbbc2f3b038e60fd97a620bff9230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a145a3766f56a33a6d845cfd0dba1890d"><td class="memItemLeft" align="right" valign="top"><a id="a145a3766f56a33a6d845cfd0dba1890d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_AI_NUMERICHOST</b>&#160;&#160;&#160;0x4000</td></tr>
<tr class="separator:a145a3766f56a33a6d845cfd0dba1890d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a067c788a683f74e43e87098a68b37e69"><td class="memItemLeft" align="right" valign="top"><a id="a067c788a683f74e43e87098a68b37e69"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_AI_NUMERICSERV</b>&#160;&#160;&#160;0x8000</td></tr>
<tr class="separator:a067c788a683f74e43e87098a68b37e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc6a3beb4ecf5b653a871949a49b53a"><td class="memItemLeft" align="right" valign="top"><a id="abbc6a3beb4ecf5b653a871949a49b53a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_AI_V4MAPPED</b>&#160;&#160;&#160;0x10000</td></tr>
<tr class="separator:abbc6a3beb4ecf5b653a871949a49b53a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a437bacd5a8915b541a3e38c965932297"><td class="memItemLeft" align="right" valign="top"><a id="a437bacd5a8915b541a3e38c965932297"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_AI_ALL</b>&#160;&#160;&#160;0x20000</td></tr>
<tr class="separator:a437bacd5a8915b541a3e38c965932297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1162c61313f61eff48a9533a3309f739"><td class="memItemLeft" align="right" valign="top"><a id="a1162c61313f61eff48a9533a3309f739"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVUTIL_AI_ADDRCONFIG</b>&#160;&#160;&#160;0x40000</td></tr>
<tr class="separator:a1162c61313f61eff48a9533a3309f739"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9d2f7f9996a6ff28db2aeb8ac8a58187"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a9d2f7f9996a6ff28db2aeb8ac8a58187">evutil_date_rfc1123</a> (char *date, const size_t datelen, const struct tm *tm)</td></tr>
<tr class="separator:a9d2f7f9996a6ff28db2aeb8ac8a58187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b00e2754d908ba05c5aa8e9c8e4f28"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL struct <a class="el" href="structevutil__monotonic__timer.html">evutil_monotonic_timer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a87b00e2754d908ba05c5aa8e9c8e4f28">evutil_monotonic_timer_new</a> (void)</td></tr>
<tr class="separator:a87b00e2754d908ba05c5aa8e9c8e4f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2874062ff988293cd4e40b220933e209"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a2874062ff988293cd4e40b220933e209">evutil_monotonic_timer_free</a> (struct <a class="el" href="structevutil__monotonic__timer.html">evutil_monotonic_timer</a> *timer)</td></tr>
<tr class="separator:a2874062ff988293cd4e40b220933e209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab486d1e10fd1e3102b4e53beed8d9baa"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#ab486d1e10fd1e3102b4e53beed8d9baa">evutil_configure_monotonic_time</a> (struct <a class="el" href="structevutil__monotonic__timer.html">evutil_monotonic_timer</a> *timer, int flags)</td></tr>
<tr class="separator:ab486d1e10fd1e3102b4e53beed8d9baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe94df86960981b69411f20c0c5235dc"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#abe94df86960981b69411f20c0c5235dc">evutil_gettime_monotonic</a> (struct <a class="el" href="structevutil__monotonic__timer.html">evutil_monotonic_timer</a> *timer, struct timeval *tp)</td></tr>
<tr class="separator:abe94df86960981b69411f20c0c5235dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d08d44d7b2823a9c4e218c69160d9ab"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a0d08d44d7b2823a9c4e218c69160d9ab">evutil_socketpair</a> (int d, int type, int protocol, <a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a> sv[2])</td></tr>
<tr class="separator:a0d08d44d7b2823a9c4e218c69160d9ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8f2384311baf5d7308c7ab079f9b84"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a4f8f2384311baf5d7308c7ab079f9b84">evutil_make_socket_nonblocking</a> (<a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a> sock)</td></tr>
<tr class="separator:a4f8f2384311baf5d7308c7ab079f9b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a8e18b7861ed856bde592257f6b6e11"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a7a8e18b7861ed856bde592257f6b6e11">evutil_make_listen_socket_reuseable</a> (<a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a> sock)</td></tr>
<tr class="separator:a7a8e18b7861ed856bde592257f6b6e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4e68f77ce876ceecc6fb65f2dbe506"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a9e4e68f77ce876ceecc6fb65f2dbe506">evutil_make_listen_socket_reuseable_port</a> (<a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a> sock)</td></tr>
<tr class="separator:a9e4e68f77ce876ceecc6fb65f2dbe506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7edc3874139e863f61edf6c705030430"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a7edc3874139e863f61edf6c705030430">evutil_make_socket_closeonexec</a> (<a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a> sock)</td></tr>
<tr class="separator:a7edc3874139e863f61edf6c705030430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cfa6c13c62d17570a7d5f6d3541ff5b"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a5cfa6c13c62d17570a7d5f6d3541ff5b">evutil_closesocket</a> (<a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a> sock)</td></tr>
<tr class="separator:a5cfa6c13c62d17570a7d5f6d3541ff5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988b1fc98edeac63efc8b13c4f822a0d"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a988b1fc98edeac63efc8b13c4f822a0d">evutil_make_tcp_listen_socket_deferred</a> (<a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a> sock)</td></tr>
<tr class="separator:a988b1fc98edeac63efc8b13c4f822a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9175e63729c256eb2646e11e8211f4f7"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL ev_int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a9175e63729c256eb2646e11e8211f4f7">evutil_strtoll</a> (const char *s, char **endptr, int base)</td></tr>
<tr class="separator:a9175e63729c256eb2646e11e8211f4f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12557f3d4c54dd80fc13f07b28ec20fd"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a12557f3d4c54dd80fc13f07b28ec20fd">evutil_gettimeofday</a> (struct timeval *tv, struct timezone *tz)</td></tr>
<tr class="separator:a12557f3d4c54dd80fc13f07b28ec20fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a198e8db3626746515792e28b1380be67"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a198e8db3626746515792e28b1380be67">evutil_snprintf</a> (char *buf, size_t buflen, const char *format,...)</td></tr>
<tr class="separator:a198e8db3626746515792e28b1380be67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30bbdc509d150e5dfac1f74dd4e4c212"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a30bbdc509d150e5dfac1f74dd4e4c212">evutil_vsnprintf</a> (char *buf, size_t buflen, const char *format, va_list ap)</td></tr>
<tr class="separator:a30bbdc509d150e5dfac1f74dd4e4c212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e345018faed07fc21f76bbdbdb8db1"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a77e345018faed07fc21f76bbdbdb8db1">evutil_inet_ntop</a> (int af, const void *src, char *dst, size_t len)</td></tr>
<tr class="separator:a77e345018faed07fc21f76bbdbdb8db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4065af1c9c995010ef7df66154c313b2"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a4065af1c9c995010ef7df66154c313b2">evutil_inet_pton</a> (int af, const char *src, void *dst)</td></tr>
<tr class="separator:a4065af1c9c995010ef7df66154c313b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d4f315d5c40c4f604f6c9ae694a684"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a97d4f315d5c40c4f604f6c9ae694a684">evutil_parse_sockaddr_port</a> (const char *str, struct sockaddr *out, int *outlen)</td></tr>
<tr class="separator:a97d4f315d5c40c4f604f6c9ae694a684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b5ad1074f1effe2dbfa18b3f44b589f"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a7b5ad1074f1effe2dbfa18b3f44b589f">evutil_sockaddr_cmp</a> (const struct sockaddr *sa1, const struct sockaddr *sa2, int include_port)</td></tr>
<tr class="separator:a7b5ad1074f1effe2dbfa18b3f44b589f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae46d8f8407906b79216f9be88803126"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#aae46d8f8407906b79216f9be88803126">evutil_ascii_strcasecmp</a> (const char *str1, const char *str2)</td></tr>
<tr class="separator:aae46d8f8407906b79216f9be88803126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b44d66883df5bfed32c9ac6df93aac"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a03b44d66883df5bfed32c9ac6df93aac">evutil_ascii_strncasecmp</a> (const char *str1, const char *str2, size_t n)</td></tr>
<tr class="separator:a03b44d66883df5bfed32c9ac6df93aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f36c2fc48c644a4f56347a25c585cc9"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a0f36c2fc48c644a4f56347a25c585cc9">evutil_getaddrinfo</a> (const char *nodename, const char *servname, const struct <a class="el" href="structevutil__addrinfo.html">evutil_addrinfo</a> *hints_in, struct <a class="el" href="structevutil__addrinfo.html">evutil_addrinfo</a> **res)</td></tr>
<tr class="separator:a0f36c2fc48c644a4f56347a25c585cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58a472b3afc5cef1e6b1c9912604381b"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a58a472b3afc5cef1e6b1c9912604381b">evutil_freeaddrinfo</a> (struct <a class="el" href="structevutil__addrinfo.html">evutil_addrinfo</a> *ai)</td></tr>
<tr class="separator:a58a472b3afc5cef1e6b1c9912604381b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d380801707529ef771b9111a014fa7"><td class="memItemLeft" align="right" valign="top"><a id="a42d380801707529ef771b9111a014fa7"></a>
EVENT2_EXPORT_SYMBOL const char *&#160;</td><td class="memItemRight" valign="bottom"><b>evutil_gai_strerror</b> (int err)</td></tr>
<tr class="separator:a42d380801707529ef771b9111a014fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0836ed5d00ccab1957419a07b7acbb56"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a0836ed5d00ccab1957419a07b7acbb56">evutil_secure_rng_get_bytes</a> (void *buf, size_t n)</td></tr>
<tr class="separator:a0836ed5d00ccab1957419a07b7acbb56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ffe53dcbe32ad55f1582a0da358ac0"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a49ffe53dcbe32ad55f1582a0da358ac0">evutil_secure_rng_init</a> (void)</td></tr>
<tr class="separator:a49ffe53dcbe32ad55f1582a0da358ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4544ddceb4e20c8c52985641ca829b7e"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a4544ddceb4e20c8c52985641ca829b7e">evutil_secure_rng_set_urandom_device_file</a> (char *fname)</td></tr>
<tr class="separator:a4544ddceb4e20c8c52985641ca829b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b5b7d22b368ffdd6ed77838bf4fcea6"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html#a3b5b7d22b368ffdd6ed77838bf4fcea6">evutil_secure_rng_add_bytes</a> (const char *dat, size_t datlen)</td></tr>
<tr class="separator:a3b5b7d22b368ffdd6ed77838bf4fcea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Common convenience functions for cross-platform portability and related socket manipulations. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a4c296955d33624c18bd4811730caa417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c296955d33624c18bd4811730caa417">&#9670;&nbsp;</a></span>evutil_offsetof</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define evutil_offsetof</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">field&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((off_t)(&amp;((type *)0)-&gt;field))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replacement for offsetof on platforms that don't define it. </p>

</div>
</div>
<a id="a7ef0023565082a65020f6e56be59fd0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ef0023565082a65020f6e56be59fd0b">&#9670;&nbsp;</a></span>evutil_socket_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define evutil_socket_t&#160;&#160;&#160;int</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A type wide enough to hold the output of "socket()" or "accept()". On Windows, this is an intptr_t; elsewhere, it is an int. </p>

</div>
</div>
<a id="a6182f91a8aede88fac748b3f424cbb6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6182f91a8aede88fac748b3f424cbb6d">&#9670;&nbsp;</a></span>evutil_timeradd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define evutil_timeradd</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tvp, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">uvp, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">vvp&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {                                \</div><div class="line">        (vvp)-&gt;tv_sec = (tvp)-&gt;tv_sec + (uvp)-&gt;tv_sec;      \</div><div class="line">        (vvp)-&gt;tv_usec = (tvp)-&gt;tv_usec + (uvp)-&gt;tv_usec;       \</div><div class="line">        if ((vvp)-&gt;tv_usec &gt;= 1000000) {            \</div><div class="line">            (vvp)-&gt;tv_sec++;                \</div><div class="line">            (vvp)-&gt;tv_usec -= 1000000;          \</div><div class="line">        }                           \</div><div class="line">    } <span class="keywordflow">while</span> (0)</div></div><!-- fragment -->
</div>
</div>
<a id="a1a42f43db6aaf6e99736329b6611175d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a42f43db6aaf6e99736329b6611175d">&#9670;&nbsp;</a></span>evutil_timercmp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define evutil_timercmp</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tvp, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">uvp, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cmp&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(((tvp)-&gt;tv_sec == (uvp)-&gt;tv_sec) ?             \</div><div class="line">     ((tvp)-&gt;tv_usec cmp (uvp)-&gt;tv_usec) :              \</div><div class="line">     ((tvp)-&gt;tv_sec cmp (uvp)-&gt;tv_sec))</div></div><!-- fragment --><p>Return true iff the tvp is related to uvp according to the relational operator cmp. Recognized values for cmp are ==, &lt;=, &lt;, &gt;=, and &gt;. </p>

</div>
</div>
<a id="ab75cdb8eae7b33eac738c46356967399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab75cdb8eae7b33eac738c46356967399">&#9670;&nbsp;</a></span>evutil_timersub</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define evutil_timersub</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tvp, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">uvp, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">vvp&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {                                \</div><div class="line">        (vvp)-&gt;tv_sec = (tvp)-&gt;tv_sec - (uvp)-&gt;tv_sec;      \</div><div class="line">        (vvp)-&gt;tv_usec = (tvp)-&gt;tv_usec - (uvp)-&gt;tv_usec;   \</div><div class="line">        if ((vvp)-&gt;tv_usec &lt; 0) {               \</div><div class="line">            (vvp)-&gt;tv_sec--;                \</div><div class="line">            (vvp)-&gt;tv_usec += 1000000;          \</div><div class="line">        }                           \</div><div class="line">    } <span class="keywordflow">while</span> (0)</div></div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aae46d8f8407906b79216f9be88803126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae46d8f8407906b79216f9be88803126">&#9670;&nbsp;</a></span>evutil_ascii_strcasecmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evutil_ascii_strcasecmp </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>As strcasecmp, but always compares the characters in locale-independent ASCII. That's useful if you're handling data in ASCII-based protocols. </p>

</div>
</div>
<a id="a03b44d66883df5bfed32c9ac6df93aac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03b44d66883df5bfed32c9ac6df93aac">&#9670;&nbsp;</a></span>evutil_ascii_strncasecmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evutil_ascii_strncasecmp </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>As strncasecmp, but always compares the characters in locale-independent ASCII. That's useful if you're handling data in ASCII-based protocols. </p>

</div>
</div>
<a id="a5cfa6c13c62d17570a7d5f6d3541ff5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cfa6c13c62d17570a7d5f6d3541ff5b">&#9670;&nbsp;</a></span>evutil_closesocket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evutil_closesocket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a>&#160;</td>
          <td class="paramname"><em>sock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do the platform-specific call needed to close a socket returned from socket() or accept().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to be closed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure </dd></dl>

</div>
</div>
<a id="ab486d1e10fd1e3102b4e53beed8d9baa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab486d1e10fd1e3102b4e53beed8d9baa">&#9670;&nbsp;</a></span>evutil_configure_monotonic_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evutil_configure_monotonic_time </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevutil__monotonic__timer.html">evutil_monotonic_timer</a> *&#160;</td>
          <td class="paramname"><em>timer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set up a struct <a class="el" href="structevutil__monotonic__timer.html">evutil_monotonic_timer</a>; flags can include EV_MONOT_PRECISE and EV_MONOT_FALLBACK. </p>

</div>
</div>
<a id="a9d2f7f9996a6ff28db2aeb8ac8a58187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d2f7f9996a6ff28db2aeb8ac8a58187">&#9670;&nbsp;</a></span>evutil_date_rfc1123()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evutil_date_rfc1123 </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>date</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>datelen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct tm *&#160;</td>
          <td class="paramname"><em>tm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Format a date string using RFC 1123 format (used in HTTP). If <code>tm</code> is NULL, current system's time will be used. The number of characters written will be returned. One should check if the return value is smaller than <code>datelen</code> to check if the result is truncated or not. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="util_8h_a9d2f7f9996a6ff28db2aeb8ac8a58187_cgraph.png" border="0" usemap="#util_8h_a9d2f7f9996a6ff28db2aeb8ac8a58187_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a58a472b3afc5cef1e6b1c9912604381b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58a472b3afc5cef1e6b1c9912604381b">&#9670;&nbsp;</a></span>evutil_freeaddrinfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL void evutil_freeaddrinfo </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevutil__addrinfo.html">evutil_addrinfo</a> *&#160;</td>
          <td class="paramname"><em>ai</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release storage allocated by evutil_getaddrinfo or evdns_getaddrinfo. </p>

</div>
</div>
<a id="a0f36c2fc48c644a4f56347a25c585cc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f36c2fc48c644a4f56347a25c585cc9">&#9670;&nbsp;</a></span>evutil_getaddrinfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evutil_getaddrinfo </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nodename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>servname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structevutil__addrinfo.html">evutil_addrinfo</a> *&#160;</td>
          <td class="paramname"><em>hints_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structevutil__addrinfo.html">evutil_addrinfo</a> **&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function clones getaddrinfo for systems that don't have it. For full details, see RFC 3493, section 6.1.</p>
<p>Limitations:</p><ul>
<li>When the system has no getaddrinfo, we fall back to gethostbyname_r or gethostbyname, with their attendant issues.</li>
<li>The AI_V4MAPPED and AI_ALL flags are not currently implemented.</li>
</ul>
<p>For a nonblocking variant, see evdns_getaddrinfo. </p>

</div>
</div>
<a id="abe94df86960981b69411f20c0c5235dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe94df86960981b69411f20c0c5235dc">&#9670;&nbsp;</a></span>evutil_gettime_monotonic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evutil_gettime_monotonic </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevutil__monotonic__timer.html">evutil_monotonic_timer</a> *&#160;</td>
          <td class="paramname"><em>timer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timeval *&#160;</td>
          <td class="paramname"><em>tp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query the current monotonic time from a struct <a class="el" href="structevutil__monotonic__timer.html">evutil_monotonic_timer</a> previously configured with <a class="el" href="util_8h.html#ab486d1e10fd1e3102b4e53beed8d9baa">evutil_configure_monotonic_time()</a>. Monotonic time is guaranteed never to run in reverse, but is not necessarily epoch- based, or relative to any other definite point. Use it to make reliable measurements of elapsed time between events even when the system time may be changed.</p>
<p>It is not safe to use this funtion on the same timer from multiple threads. </p>

</div>
</div>
<a id="a12557f3d4c54dd80fc13f07b28ec20fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12557f3d4c54dd80fc13f07b28ec20fd">&#9670;&nbsp;</a></span>evutil_gettimeofday()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evutil_gettimeofday </td>
          <td>(</td>
          <td class="paramtype">struct timeval *&#160;</td>
          <td class="paramname"><em>tv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timezone *&#160;</td>
          <td class="paramname"><em>tz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>evutil_usleep_() </p>

</div>
</div>
<a id="a77e345018faed07fc21f76bbdbdb8db1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77e345018faed07fc21f76bbdbdb8db1">&#9670;&nbsp;</a></span>evutil_inet_ntop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL const char* evutil_inet_ntop </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>af</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replacement for inet_ntop for platforms which lack it. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="util_8h_a77e345018faed07fc21f76bbdbdb8db1_cgraph.png" border="0" usemap="#util_8h_a77e345018faed07fc21f76bbdbdb8db1_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a4065af1c9c995010ef7df66154c313b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4065af1c9c995010ef7df66154c313b2">&#9670;&nbsp;</a></span>evutil_inet_pton()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evutil_inet_pton </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>af</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replacement for inet_pton for platforms which lack it. </p>

</div>
</div>
<a id="a7a8e18b7861ed856bde592257f6b6e11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a8e18b7861ed856bde592257f6b6e11">&#9670;&nbsp;</a></span>evutil_make_listen_socket_reuseable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evutil_make_listen_socket_reuseable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a>&#160;</td>
          <td class="paramname"><em>sock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do platform-specific operations to make a listener socket reusable.</p>
<p>Specifically, we want to make sure that another program will be able to bind this address right after we've closed the listener.</p>
<p>This differs from Windows's interpretation of "reusable", which allows multiple listeners to bind the same address at the same time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to make reusable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure </dd></dl>

</div>
</div>
<a id="a9e4e68f77ce876ceecc6fb65f2dbe506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e4e68f77ce876ceecc6fb65f2dbe506">&#9670;&nbsp;</a></span>evutil_make_listen_socket_reuseable_port()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evutil_make_listen_socket_reuseable_port </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a>&#160;</td>
          <td class="paramname"><em>sock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do platform-specific operations to make a listener port reusable.</p>
<p>Specifically, we want to make sure that multiple programs which also set the same socket option will be able to bind, listen at the same time.</p>
<p>This is a feature available only to Linux 3.9+</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to make reusable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure </dd></dl>

</div>
</div>
<a id="a7edc3874139e863f61edf6c705030430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7edc3874139e863f61edf6c705030430">&#9670;&nbsp;</a></span>evutil_make_socket_closeonexec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evutil_make_socket_closeonexec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a>&#160;</td>
          <td class="paramname"><em>sock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do platform-specific operations as needed to close a socket upon a successful execution of one of the exec*() functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to be closed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure </dd></dl>

</div>
</div>
<a id="a4f8f2384311baf5d7308c7ab079f9b84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f8f2384311baf5d7308c7ab079f9b84">&#9670;&nbsp;</a></span>evutil_make_socket_nonblocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evutil_make_socket_nonblocking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a>&#160;</td>
          <td class="paramname"><em>sock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do platform-specific operations as needed to make a socket nonblocking.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to make nonblocking </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure </dd></dl>

</div>
</div>
<a id="a988b1fc98edeac63efc8b13c4f822a0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a988b1fc98edeac63efc8b13c4f822a0d">&#9670;&nbsp;</a></span>evutil_make_tcp_listen_socket_deferred()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evutil_make_tcp_listen_socket_deferred </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a>&#160;</td>
          <td class="paramname"><em>sock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do platform-specific operations, if possible, to make a tcp listener socket defer accept()s until there is data to read.</p>
<p>Not all platforms support this. You don't want to do this for every listener socket: only the ones that implement a protocol where the client transmits before the server needs to respond.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The listening socket to to make deferred </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success (whether the operation is supported or not), -1 on failure </dd></dl>

</div>
</div>
<a id="a2874062ff988293cd4e40b220933e209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2874062ff988293cd4e40b220933e209">&#9670;&nbsp;</a></span>evutil_monotonic_timer_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL void evutil_monotonic_timer_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevutil__monotonic__timer.html">evutil_monotonic_timer</a> *&#160;</td>
          <td class="paramname"><em>timer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free a struct <a class="el" href="structevutil__monotonic__timer.html">evutil_monotonic_timer</a> that was allocated using <a class="el" href="util_8h.html#a87b00e2754d908ba05c5aa8e9c8e4f28">evutil_monotonic_timer_new()</a>. </p>

</div>
</div>
<a id="a87b00e2754d908ba05c5aa8e9c8e4f28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87b00e2754d908ba05c5aa8e9c8e4f28">&#9670;&nbsp;</a></span>evutil_monotonic_timer_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL struct <a class="el" href="structevutil__monotonic__timer.html">evutil_monotonic_timer</a>* evutil_monotonic_timer_new </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate a new struct <a class="el" href="structevutil__monotonic__timer.html">evutil_monotonic_timer</a> for use with the <a class="el" href="util_8h.html#ab486d1e10fd1e3102b4e53beed8d9baa">evutil_configure_monotonic_time()</a> and <a class="el" href="util_8h.html#abe94df86960981b69411f20c0c5235dc">evutil_gettime_monotonic()</a> functions. You must configure the timer with <a class="el" href="util_8h.html#ab486d1e10fd1e3102b4e53beed8d9baa">evutil_configure_monotonic_time()</a> before using it. </p>

</div>
</div>
<a id="a97d4f315d5c40c4f604f6c9ae694a684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97d4f315d5c40c4f604f6c9ae694a684">&#9670;&nbsp;</a></span>evutil_parse_sockaddr_port()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evutil_parse_sockaddr_port </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sockaddr *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>outlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parse an IPv4 or IPv6 address, with optional port, from a string.</p>
<p>Recognized formats are:</p><ul>
<li>[IPv6Address]:port</li>
<li>[IPv6Address]</li>
<li>IPv6Address</li>
<li>IPv4Address:port</li>
<li>IPv4Address</li>
</ul>
<p>If no port is specified, the port in the output is set to 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to parse. </td></tr>
    <tr><td class="paramname">out</td><td>A struct sockaddr to hold the result. This should probably be a struct <a class="el" href="structsockaddr__storage.html">sockaddr_storage</a>. </td></tr>
    <tr><td class="paramname">outlen</td><td>A pointer to the number of bytes that that 'out' can safely hold. Set to the number of bytes used in 'out' on success. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if the address is not well-formed, if the port is out of range, or if out is not large enough to hold the result. Otherwise returns 0 on success. </dd></dl>

</div>
</div>
<a id="a3b5b7d22b368ffdd6ed77838bf4fcea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b5b7d22b368ffdd6ed77838bf4fcea6">&#9670;&nbsp;</a></span>evutil_secure_rng_add_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL void evutil_secure_rng_add_bytes </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>datlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Seed the random number generator with extra random bytes.</p>
<p>You should almost never need to call this function; it should be sufficient to invoke <a class="el" href="util_8h.html#a49ffe53dcbe32ad55f1582a0da358ac0">evutil_secure_rng_init()</a>, or let Libevent take care of calling <a class="el" href="util_8h.html#a49ffe53dcbe32ad55f1582a0da358ac0">evutil_secure_rng_init()</a> on its own.</p>
<p>If you call this function as a <em>replacement</em> for the regular entropy sources, then you need to be sure that your input contains a fairly large amount of strong entropy. Doing so is notoriously hard: most people who try get it wrong. Watch out!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dat</td><td>a buffer full of a strong source of random numbers </td></tr>
    <tr><td class="paramname">datlen</td><td>the number of bytes to read from datlen </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0836ed5d00ccab1957419a07b7acbb56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0836ed5d00ccab1957419a07b7acbb56">&#9670;&nbsp;</a></span>evutil_secure_rng_get_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL void evutil_secure_rng_get_bytes </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate n bytes of secure pseudorandom data, and store them in buf.</p>
<p>Current versions of Libevent use an ARC4-based random number generator, seeded using the platform's entropy source (/dev/urandom on Unix-like systems; CryptGenRandom on Windows). This is not actually as secure as it should be: ARC4 is a pretty lousy cipher, and the current implementation provides only rudimentary prediction- and backtracking-resistance. Don't use this for serious cryptographic applications. </p>

</div>
</div>
<a id="a49ffe53dcbe32ad55f1582a0da358ac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49ffe53dcbe32ad55f1582a0da358ac0">&#9670;&nbsp;</a></span>evutil_secure_rng_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evutil_secure_rng_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Seed the secure random number generator if needed, and return 0 on success or -1 on failure.</p>
<p>It is okay to call this function more than once; it will still return 0 if the RNG has been successfully seeded and -1 if it can't be seeded.</p>
<p>Ordinarily you don't need to call this function from your own code; Libevent will seed the RNG itself the first time it needs good random numbers. You only need to call it if (a) you want to double-check that one of the seeding methods did succeed, or (b) you plan to drop the capability to seed (by chrooting, or dropping capabilities, or whatever), and you want to make sure that seeding happens before your program loses the ability to do it. </p>

</div>
</div>
<a id="a4544ddceb4e20c8c52985641ca829b7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4544ddceb4e20c8c52985641ca829b7e">&#9670;&nbsp;</a></span>evutil_secure_rng_set_urandom_device_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evutil_secure_rng_set_urandom_device_file </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>fname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a filename to use in place of /dev/urandom for seeding the secure PRNG. Return 0 on success, -1 on failure.</p>
<p>Call this function BEFORE calling any other initialization or RNG functions.</p>
<p>(This string will <em>NOT</em> be copied internally. Do not free it while any user of the secure RNG might be running. Don't pass anything other than a real /dev/...random device file here, or you might lose security.)</p>
<p>This API is unstable, and might change in a future libevent version. </p>

</div>
</div>
<a id="a198e8db3626746515792e28b1380be67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a198e8db3626746515792e28b1380be67">&#9670;&nbsp;</a></span>evutil_snprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evutil_snprintf </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buflen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replacement for snprintf to get consistent behavior on platforms for which the return value of snprintf does not conform to C99. </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="util_8h_a198e8db3626746515792e28b1380be67_cgraph.png" border="0" usemap="#util_8h_a198e8db3626746515792e28b1380be67_cgraph" alt=""/></div>
</div>

</div>
</div>
<a id="a7b5ad1074f1effe2dbfa18b3f44b589f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b5ad1074f1effe2dbfa18b3f44b589f">&#9670;&nbsp;</a></span>evutil_sockaddr_cmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evutil_sockaddr_cmp </td>
          <td>(</td>
          <td class="paramtype">const struct sockaddr *&#160;</td>
          <td class="paramname"><em>sa1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct sockaddr *&#160;</td>
          <td class="paramname"><em>sa2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>include_port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compare two sockaddrs; return 0 if they are equal, or less than 0 if sa1 preceeds sa2, or greater than 0 if sa1 follows sa2. If include_port is true, consider the port as well as the address. Only implemented for AF_INET and AF_INET6 addresses. The ordering is not guaranteed to remain the same between Libevent versions. </p>

</div>
</div>
<a id="a0d08d44d7b2823a9c4e218c69160d9ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d08d44d7b2823a9c4e218c69160d9ab">&#9670;&nbsp;</a></span>evutil_socketpair()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evutil_socketpair </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a>&#160;</td>
          <td class="paramname"><em>sv</em>[2]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create two new sockets that are connected to each other.</p>
<p>On Unix, this simply calls socketpair(). On Windows, it uses the loopback network interface on 127.0.0.1, and only AF_INET,SOCK_STREAM are supported.</p>
<p>(This may fail on some Windows hosts where firewall software has cleverly decided to keep 127.0.0.1 from talking to itself.)</p>
<p>Parameters and return values are as for socketpair() </p>

</div>
</div>
<a id="a9175e63729c256eb2646e11e8211f4f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9175e63729c256eb2646e11e8211f4f7">&#9670;&nbsp;</a></span>evutil_strtoll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL ev_int64_t evutil_strtoll </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>endptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parse a 64-bit value from a string. Arguments are as for strtol. </p>

</div>
</div>
<a id="a30bbdc509d150e5dfac1f74dd4e4c212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30bbdc509d150e5dfac1f74dd4e4c212">&#9670;&nbsp;</a></span>evutil_vsnprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL int evutil_vsnprintf </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buflen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>ap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replacement for vsnprintf to get consistent behavior on platforms for which the return value of snprintf does not conform to C99. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
